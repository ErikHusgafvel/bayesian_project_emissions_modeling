---
title: \vspace{3in}BDA - Project
author: "Tomi Räsänen - 879626 & Erik Husgafvel - 528867"
bibliography: bibliography.bib
output:
 pdf_document:
   toc: true
   toc_depth: 1
   includes:
     before_body: latex/before_body.tex
   extra_dependencies: ["amsmath"]
---

\newpage


# 1. Introduction

One of the biggest challenges of humankind in the 2020s is figuring out ways to slow down the growth of greenhouse gas emissions and stop global warming (due to human activities) under 2 $^{\circ}$C. The increasing trend of global temperature is easily seen in Figure \ref{fig:global_temp} [cite NASA] in which the global surface temperature is illustrated relative to 1951-1980 average temperatures. Warming can also be seen with one's own eyes by observing the winters that are warming year by year, by noticing that the number of devastating hurricanes is increased, and by finding out the increased rate of ice melting in glaciers during summer.

```{r globaltemp, echo=FALSE, fig.cap="\\label{fig:global_temp}Global Land-Ocean Temperature Index", out.width = '100%'}
knitr::include_graphics("GlobalTemp.png")
```

In response to that warming, many countries have declared a climate emergency to emphasize the criticality of the situation. In addition, young people have organized climate demonstrations around the world, politicians are talking more and more about climate change, and presidents and prime ministers are negotiating agreements and commitments to solve this, one of humanity’s greatest, problem.  But what if, despite attempts of negotiation, the necessary CO$_2$ reduction decisions are not achieved?

In this project, our goal is to model the historical emission trends of selected countries as well as attempts to model their future emissions. We are examining a scenario in which emissions continue to develop at a historical rate, and the necessary reductions are not achieved. In our modeling, the other parameters e.g. population growth and technical conditions, are similar to historical data in our modeling. 


# 2. Data description


Our CO$_2$ data was obtained from \textit{Our World in Data} (OWID) web page [cite OWID_net] and the actual \textit{CSV} file from OWID GitHub page [cite OWID_git]. As mentioned earlier, climate change is a hot topic in the daily news, and there is a lot of studies and research concerning how CO$_2$ emissions are influencing global warming. The data set was also used, for example, when researchers studied the climate impact of the different policy recommendation which targeted to reduce greenhouse gases from the atmosphere.

In our modeling, we are going to select 19 different countries from that OWID data set and examine CO$_2$ data between the years 1950-2018. The countries we have chosen cover the whole globe and are roughly evenly distributed across continents. There are both small and large polluters among the countries.

```{r message=FALSE}
library(rstan)
library(ggplot2)
library(reshape2)
library(gridExtra)
```

```{r}
# Read data to data frame
data_co2 <- read.csv("./data_co2.csv")
data_population <- head(read.csv("./data_population.csv"), -1)
data_co2_population = data_co2*10^6/data_population

# We discovered that the CO2-emissions difference between our selected countries is so vast
# that it's better to split the data into two different plots.

df_data1 <- data_co2[, (data_co2[dim(data_co2)[1], ]) >= 100]
df_data1 <- df_data1[,order(df_data1[69,])]
df_data1_2 <- data.frame(years=seq(1950,2018), df_data1)
df_plot1 <- melt(data = df_data1_2, id.vars = "years", variable.name = "Country")


df_data2 <- data_co2[, (data_co2[dim(data_co2)[1], ]) < 100]
df_data2 <- df_data2[,order(df_data2[69,])]
df_data2_2 <- data.frame(years=seq(1950,2018), df_data2)
df_plot2 <- melt(data = df_data2_2, id.vars = "years", variable.name = "Country")

# Population
# df_data3 <- data.frame(years=seq(1950,2018), data_population)
# df_plot3 <- melt(data = df_data3, id.vars = "years", variable.name = "Country")


df_data4 <- data.frame(years=seq(1950,2018), data_co2_population)
df_data4 <- df_data4[,order(df_data4[69,])]
df_plot4 <- melt(data = df_data4, id.vars = "years", variable.name = "Country")

# df_data5 <- data_c02_population[, (data_co2[dim(data_co2)[1], ]) < 100]
# df_data5 <- df_data5[,order(df_data5[69,])]
# df_data5_2 <- data.frame(years=seq(1950,2018), df_data5)
# df_plot5 <- melt(data = df_data5_2, id.vars = "years", variable.name = "Country")


plot1 <- ggplot(df_plot1, aes(x=years, y=value, colour=Country)) +
        geom_line() +
        ggtitle("Selected countries' co2-emissions: \nbig emitters") +
        xlab("Year") +
        ylab("CO2-emissions / Billion tonns") +
        labs(colour = "IOC Country Code") +
        theme(
          axis.title.x = element_text(face = "bold"),
          axis.title.y = element_text(face = "bold"))

plot2 <- ggplot(df_plot2, aes(x=years, y=value, colour=Country)) +
        geom_line() +
        ggtitle("Selected countries' co2-emissions: \nsmall emitters") +
        xlab("Year") +
        ylab("CO2-emissions / Billion tonns") +
        labs(colour = "IOC Country Code") +
        theme(
          axis.title.x = element_text(face = "bold"),
          axis.title.y = element_text(face = "bold"))

# plot3 <- ggplot(df_plot3, aes(x=years, y=value, colour=Country)) +
#         geom_line() +
#         ggtitle("Selected countries' population development") +
#         xlab("Year") +
#         ylab("Population")

plot4 <- ggplot(df_plot4, aes(x=years, y=value, colour=Country)) +
        geom_line() +
        ggtitle("CO2 / Population Development") +
        xlab("Year") +
        ylab("CO2 Per Capita / Kilo tonns") +
        labs(colour = "IOC Country Code") +
        theme(
          axis.title.x = element_text(face = "bold"),
          axis.title.y = element_text(face = "bold"))

# plot5 <- ggplot(df_plot5, aes(x=years, y=value, colour=Country)) +
#         geom_line() +
#         ggtitle("co2 / Population development small") +
#         xlab("Year") +
#         ylab("co2 per capita")
```

```{r fig1, fig.height=12, fig.width=10, fig.align="center"}

grid.arrange(
  grobs = list(plot1, plot2, plot4),
  layout_matrix = rbind(c(1, 1, 2, 2),
                        c(3, 3, 3, 3),
                        c(3, 3, 3, 3))
)
#plot5
```

```{r}
data_co2_population = data_co2*10^6/data_population

df_data4 <- data.frame(years=seq(1950,2018), data_co2_population)
df_data4 <- df_data4[,order(df_data4[69,])]
df_plot4 <- melt(data = df_data4, id.vars = "years", variable.name = "country")

#df_data5 <- data_c02_population[, (data_co2[dim(data_co2)[1], ]) < 100]
#df_data5 <- df_data5[,order(df_data5[69,])]
#df_data5_2 <- data.frame(years=seq(1950,2018), df_data5)
#df_plot5 <- melt(data = df_data5_2, id.vars = "years", variable.name = "country")

plot4 <- ggplot(df_plot4, aes(x=years, y=value, colour=country)) +
        geom_line() +
        ggtitle("CO2 / Population Development") +
        xlab("Year") +
        ylab("CO2 Per Capita / Kilo tonns")

```





Example code for pooled model from assignment


data {
  int <lower=0> N; // number of observations
  vector[N] y; // observations
}

parameters {
  real mu;
  real<lower=0> sigma;
}

model {
    mu ~ lognormal(0, 10); // priors from last week
    sigma ~ inv_chi_square(1); // priors from last week
  
  
  // pooled model likelihood, common mu and sigma for all observations
    y ~ normal(mu, sigma);
}


generated quantities {
    real ypred;
    vector[N] log_lik;
  
  //predictive distribution for any machine
    ypred = normal_rng(mu, sigma);
  
    for (i in 1:N){
      log_lik[i] = normal_lpdf(y[i] | mu, sigma);
    }
}


```{stan output.var=hiermodel}
data {
    int<lower=0> N;            // Number of observations
    int<lower=0> N_c;            // Number of countries
    vector[N_c] y[N];               // Observations
}
parameters {
    vector[N_c] mu; // group means
    real hyper_mu;             // prior mean
    real<lower=0> hyper_sigma; // prior std constrained to be positive
    real<lower=0> sigma;  // COMMON std constrained to be positive
    
}
model {
    hyper_mu ~ normal(0, 100);     // weakly informative hyper-prior
    hyper_sigma ~ inv_chi_square(1);   // weakly informative hyper-prior
    
    mu ~ normal(hyper_mu, hyper_sigma); // population prior with unknown parameters   
    sigma ~ inv_chi_square(1); // weakly informative prior for group (common) std
    
    for (j in 1:N_c) {
          y[ ,j] ~ normal(mu[j], sigma); // likelihood
    }
    
}
//generated  quantities {
//real y_pred;
//    y_pred = normal_rng(hyper_mu, sigma);
//}


```


```{r message=FALSE}

df_data <- data.frame(years=seq(1950,2018), data_co2_population)
df_plot <- melt(data = df_data, id.vars = "years", variable.name = "country")
vectored_data_pop <- data.frame(df_plot[,'value'])
N <- nrow(vectored_data_pop)


# # Printing out our hierarchical model
# writeLines(readLines("assignment9_hierarchical_model.stan"))

num_of_chains = 4

pool_data <- list(N = N,
                  y = vectored_data_pop[,1])

pool_model <- rstan::stan_model(file = "pooled_model_stan.stan")

pool_fit <- rstan::sampling(object = pool_model,
                            data = pool_data,
                            iter = 2000,
                            warmup = 1000)

hier_data <- list(N = nrow(data_co2_population),
                  N_c = ncol(data_co2_population),
                  y = data_co2_population)

hier_fit <- rstan::sampling(object = hiermodel,
                            data = hier_data,
                            iter = 2000,
                            warmup = 1000,
                            refresh = 0)
monitor(pool_fit)
monitor(hier_fit)

pooled_df =data.frame(rstan::extract(pool_fit, permuted=FALSE))
# Plot the posterior distribution of
# the mean of the quality measurements of the sixth machine
pooled_post =c(pooled_df$chain.1.mu,
               pooled_df$chain.2.mu,
               pooled_df$chain.3.mu,
               pooled_df$chain.4.mu)
hist(pooled_post, 
     breaks = 30,
     xlab = "Mean of the quality measurements",
     col = "lightyellow",
     main="Posterior distribution of the mean of the sixth machine")

pool_model <- rstan::stan_model(file = "pooled_model_stan.stan")

pool_fit <- rstan::sampling(object = pool_model,
                            data = pool_data,
                            iter = 2000,
                            warmup = 1000,
                            seed = SEED)

```

# References

